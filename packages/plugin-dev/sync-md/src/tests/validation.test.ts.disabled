import { describe, expect, it } from '@jest/globals';
import {
  hasCircularReference,
  sanitizeFilePath,
  validateMarkdownContent,
  validateSyncConfig,
  validateTask,
  validateTaskHierarchy,
  validateTasks,
} from '../shared/validation';
import type { SyncConfig, Task } from '../shared/types';

describe('Validation Utilities', () => {
  describe('validateSyncConfig', () => {
    it('should validate correct config', () => {
      const config: SyncConfig = {
        enabled: true,
        filePath: '/test/file.md',
        projectId: 'proj1',
        syncDirection: 'bidirectional',
      };

      expect(validateSyncConfig(config)).toBe(true);
    });

    it('should reject invalid configs', () => {
      expect(() => validateSyncConfig(null)).toThrow('must be an object');
      expect(() => validateSyncConfig(undefined)).toThrow('must be an object');
      expect(() => validateSyncConfig('string')).toThrow('must be an object');

      expect(() => validateSyncConfig({ enabled: 'yes' })).toThrow(
        'enabled must be a boolean',
      );
      expect(() => validateSyncConfig({ enabled: true })).toThrow('filePath must be');
      expect(() => validateSyncConfig({ enabled: true, filePath: '' })).toThrow(
        'filePath must be',
      );
      expect(() =>
        validateSyncConfig({
          enabled: true,
          filePath: '/test.md',
        }),
      ).toThrow('projectId must be');

      expect(() =>
        validateSyncConfig({
          enabled: true,
          filePath: '/test.md',
          projectId: 'proj1',
          syncDirection: 'invalid',
        }),
      ).toThrow('syncDirection must be one of');
    });

    it('should reject file paths with null bytes', () => {
      expect(() =>
        validateSyncConfig({
          enabled: true,
          filePath: '/test\0file.md',
          projectId: 'proj1',
          syncDirection: 'bidirectional',
        }),
      ).toThrow('contains null bytes');
    });
  });

  describe('validateTask', () => {
    it('should validate correct task', () => {
      const task: Task = {
        id: 'task1',
        title: 'Test Task',
        isDone: false,
        projectId: 'proj1',
      };

      expect(validateTask(task)).toBe(true);
    });

    it('should validate task with optional fields', () => {
      const task: Task = {
        id: 'task1',
        title: 'Test Task',
        isDone: false,
        projectId: 'proj1',
        parentId: 'parent1',
        subTaskIds: ['sub1', 'sub2'],
        notes: 'Some notes',
      };

      expect(validateTask(task)).toBe(true);
    });

    it('should reject invalid tasks', () => {
      expect(() => validateTask(null)).toThrow('must be an object');
      expect(() => validateTask({})).toThrow('id must be');
      expect(() => validateTask({ id: '' })).toThrow('id must be');
      expect(() => validateTask({ id: 'task1' })).toThrow('title must be');
      expect(() =>
        validateTask({
          id: 'task1',
          title: 123,
        }),
      ).toThrow('title must be a string');

      expect(() =>
        validateTask({
          id: 'task1',
          title: 'Test',
          isDone: 'no',
        }),
      ).toThrow('isDone must be a boolean');

      expect(() =>
        validateTask({
          id: 'task1',
          title: 'Test',
          isDone: false,
          projectId: '',
        }),
      ).toThrow('projectId must be');
    });

    it('should validate optional fields correctly', () => {
      expect(() =>
        validateTask({
          id: 'task1',
          title: 'Test',
          isDone: false,
          projectId: 'proj1',
          parentId: 123,
        }),
      ).toThrow('parentId must be a string or null');

      expect(() =>
        validateTask({
          id: 'task1',
          title: 'Test',
          isDone: false,
          projectId: 'proj1',
          subTaskIds: 'not-array',
        }),
      ).toThrow('subTaskIds must be an array');

      expect(() =>
        validateTask({
          id: 'task1',
          title: 'Test',
          isDone: false,
          projectId: 'proj1',
          subTaskIds: ['valid', 123],
        }),
      ).toThrow('all subTaskIds must be strings');
    });
  });

  describe('validateTasks', () => {
    it('should validate array of tasks', () => {
      const tasks: Task[] = [
        { id: '1', title: 'Task 1', isDone: false, projectId: 'proj1' },
        { id: '2', title: 'Task 2', isDone: true, projectId: 'proj1' },
      ];

      expect(validateTasks(tasks)).toBe(true);
    });

    it('should reject non-array input', () => {
      expect(() => validateTasks('not-array')).toThrow('must be an array');
      expect(() => validateTasks(null)).toThrow('must be an array');
    });

    it('should report index of invalid task', () => {
      const tasks = [
        { id: '1', title: 'Valid', isDone: false, projectId: 'proj1' },
        { id: '', title: 'Invalid', isDone: false, projectId: 'proj1' },
      ];

      expect(() => validateTasks(tasks)).toThrow('Invalid task at index 1');
    });
  });

  describe('sanitizeFilePath', () => {
    it('should remove null bytes', () => {
      expect(sanitizeFilePath('/test\0file.md')).toBe('/test/file.md');
    });

    it('should normalize path separators', () => {
      expect(sanitizeFilePath('C:\\Users\\test\\file.md')).toBe('C:/Users/test/file.md');
    });

    it('should remove double slashes except in protocol', () => {
      expect(sanitizeFilePath('/test//path///file.md')).toBe('/test/path/file.md');
      expect(sanitizeFilePath('http://example.com/path')).toBe('http://example.com/path');
    });

    it('should trim whitespace', () => {
      expect(sanitizeFilePath('  /test/file.md  ')).toBe('/test/file.md');
    });
  });

  describe('validateMarkdownContent', () => {
    it('should validate string content', () => {
      expect(validateMarkdownContent('# Valid markdown')).toBe(true);
      expect(validateMarkdownContent('')).toBe(true);
    });

    it('should reject non-string content', () => {
      expect(() => validateMarkdownContent(123)).toThrow('must be a string');
      expect(() => validateMarkdownContent(null)).toThrow('must be a string');
      expect(() => validateMarkdownContent(undefined)).toThrow('must be a string');
    });

    it('should reject content over 10MB', () => {
      const largeContent = 'x'.repeat(11 * 1024 * 1024);
      expect(() => validateMarkdownContent(largeContent)).toThrow('exceeds 10MB limit');
    });
  });

  describe('hasCircularReference', () => {
    it('should detect direct circular reference', () => {
      const taskMap = new Map([
        ['task1', { parentId: 'task2' }],
        ['task2', { parentId: 'task1' }],
      ]);

      expect(hasCircularReference('task1', 'task2', taskMap)).toBe(true);
    });

    it('should detect indirect circular reference', () => {
      const taskMap = new Map([
        ['task1', { parentId: 'task2' }],
        ['task2', { parentId: 'task3' }],
        ['task3', { parentId: 'task1' }],
      ]);

      expect(hasCircularReference('task1', 'task2', taskMap)).toBe(true);
    });

    it('should not detect false positives', () => {
      const taskMap = new Map([
        ['task1', { parentId: null }],
        ['task2', { parentId: 'task1' }],
        ['task3', { parentId: 'task2' }],
      ]);

      expect(hasCircularReference('task3', 'task2', taskMap)).toBe(false);
    });

    it('should handle self-reference', () => {
      const taskMap = new Map([['task1', { parentId: 'task1' }]]);

      expect(hasCircularReference('task1', 'task1', taskMap)).toBe(true);
    });
  });

  describe('validateTaskHierarchy', () => {
    it('should validate correct hierarchy', () => {
      const tasks: Task[] = [
        {
          id: 'parent',
          title: 'Parent',
          isDone: false,
          projectId: 'proj1',
          subTaskIds: ['child'],
        },
        {
          id: 'child',
          title: 'Child',
          isDone: false,
          projectId: 'proj1',
          parentId: 'parent',
        },
      ];

      expect(() => validateTaskHierarchy(tasks)).not.toThrow();
    });

    it('should detect duplicate IDs', () => {
      const tasks: Task[] = [
        { id: 'task1', title: 'Task 1', isDone: false, projectId: 'proj1' },
        { id: 'task1', title: 'Duplicate', isDone: false, projectId: 'proj1' },
      ];

      expect(() => validateTaskHierarchy(tasks)).toThrow(
        'Duplicate task ID found: task1',
      );
    });

    it('should detect non-existent parent references', () => {
      const tasks: Task[] = [
        {
          id: 'task1',
          title: 'Task 1',
          isDone: false,
          projectId: 'proj1',
          parentId: 'missing',
        },
      ];

      expect(() => validateTaskHierarchy(tasks)).toThrow(
        'references non-existent parent missing',
      );
    });

    it('should detect non-existent subtask references', () => {
      const tasks: Task[] = [
        {
          id: 'task1',
          title: 'Task 1',
          isDone: false,
          projectId: 'proj1',
          subTaskIds: ['missing'],
        },
      ];

      expect(() => validateTaskHierarchy(tasks)).toThrow(
        'references non-existent subtask missing',
      );
    });

    it('should detect circular references in hierarchy', () => {
      const tasks: Task[] = [
        {
          id: 'task1',
          title: 'Task 1',
          isDone: false,
          projectId: 'proj1',
          parentId: 'task2',
        },
        {
          id: 'task2',
          title: 'Task 2',
          isDone: false,
          projectId: 'proj1',
          parentId: 'task1',
        },
      ];

      expect(() => validateTaskHierarchy(tasks)).toThrow('Circular reference detected');
    });
  });
});
